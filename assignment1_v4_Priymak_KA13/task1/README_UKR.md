# Завдання 1: Компіляція Python.

- [Завдання 1: Компіляція Python.](#завдання-1-компіляція-python)
  - [ЧАСТИНА 0: Введення.](#частина-0-введення)
  - [ЧАСТИНА 1: Лічильник If/Loop.](#частина-1-лічильник-ifloop)
  - [ЧАСТИНА 2. Детектор рекурсії.](#частина-2-детектор-рекурсії)
    - [Тести](#тести)
  - [Обчислення константних виразів.](#обчислення-константних-виразів)



## ЧАСТИНА 0: Введення.

В цьому завданні, вам потрібно використати модуль `ast` для побудови Абстрактних Синтаксичних Дерев функцій та їх модифікації відповідно до вимог. Див. лекцію 3 для деталей.

Будь ласка, встановіть модуль `pytest` щоб мати можливість тестувати код.
```bash
pip install pytest
# або pip3 якщо ви використовуєте глобальне середовище.
```

Тепер ви можете запускати тести:
```bash
pytest <filename>
```

Чим більша кількість тестів проходить успішно, тим краща оцінка.

## ЧАСТИНА 1: Лічильник If/Loop.
Реалізуйте [декоратор](https://stackoverflow.com/questions/739654/how-do-i-make-function-decorators-and-chain-them-together/1594484#1594484) `my_counter`, яки рахує кількість умовних операторів `If` (`if`/`elif`) та `Loop` (`for`/`while`) циклів.
Він має записувати ці кількості в атрибути декорованої функції, тобто

```Python
@my_counter
def my_function():
    if 1:
        for i in range(100):
            if i % 2 == 0:
                print(i)

print(my_function.num_loops)
# Output: 1
print(my_function.num_ifs)
# Output: 2
```

## ЧАСТИНА 2. Детектор рекурсії.
Реалізуйте функцію `has_recursion`, що визначає чи є вхідна функція рекурентною.
Наприклад:

```python
def func1(i: int):
    if i > 0:
        func1(i)

def func2(i: int):
    return

def func3_1(i: int):
    func3_2(i)

def func3_2(i: int):
    if i > 0:
        func3_1(i)

has_recursion(func1)
> True
has_recursion(func2)
> False
has_recursion(func3_2)
> True
has_recursion(func3_1)
> True
```

Рішення також має розпізнавати перехресна рекурсія будь-якої глибини як рекурсію.

### Тести
1. Проста рекурсія.
2. Перехресна рекурсія.
3. Великий приклад.
4. Синоніми (*).

## Обчислення константних виразів.

Реалізувати два декоратори: `constexpr` та `eval_const_exprs`. Перший має помічати функцію як "чисту", тобто таку, що не змінює зовнішній стан програми і не є замиканням. "чистоту" функції можна припустити - перевіряти це не потрібно. Другий має знаходити виклики помічених функцій зі сталими аргументами, обчислювати їх результат і підставляти його замість цього виклику.

Наприклад:
```Python
@constexpr
def f(a, b):
    return a + b

@eval_const_exprs
def my_function(a):
    return f(3, 6) + f(a, 3)

code(my_function)
> def my_function(a):
>    return 9 + f(a, 3)
```

* Помічайте функції декоровані `constexpr`. Це можна реалізувати просто додаванням флагу-атрибуту до декорованої функції (`f.is_marked_constexpr = True`), наявність якого можна перевірити використовуючи `hasattr`.

2. Then, traverse the AST of a function wrapped with `@eval_const_exprs`,
look for functions, see if a function is marked as `constexpr`,
and if its arguments are constant (e.g. literals) - evaluate them.
3. Додаткові тести включають більш складний вивід константних виразів в аргументах, як `f(3+3, 6)`.